# 295. 数据流的中位数

## 题意

支持两种操作：
- **addNum(num)**：向数据流中加入一个数；
- **findMedian()**：返回当前已加入数字的**中位数**（排序后中间那个；若个数为偶数，取中间两个的平均值）。

要求 addNum 与 findMedian 尽量高效。

## 思路：双堆（左大顶 + 右小顶）

把当前所有数**按大小分成两半**：
- **左半**：较小的一半，用**大顶堆**维护，堆顶是左半里的最大值；
- **右半**：较大的一半，用**小顶堆**维护，堆顶是右半里的最小值。

这样：
- 左半最大值 ≤ 右半最小值；
- 中位数只和两个堆顶有关：奇数个时取左堆顶（或约定取右堆顶），偶数个时取两堆顶的平均值。

## 维护的不变量

1. **数值关系**：左半任意数 ≤ 右半任意数（即 `left 堆顶 ≤ right 堆顶`）。
2. **个数关系**：`len(left) >= len(right)`，且最多多 1。这样总数奇数时中位数就是 left 堆顶，偶数时是两堆顶的平均值。

## AddNum(num) 步骤

1. 先把 `num` 放进**左堆**（大顶堆）：`Push(left, num)`。
2. 为了保持「左半 ≤ 右半」，把左堆的堆顶（当前左半最大）弹出并放进右堆：`Push(right, Pop(left))`。
3. 再保证「左不少于右」：若此时 `len(right) > len(left)`，把右堆堆顶弹出并放回左堆：`Push(left, Pop(right))`。

这样每次加数后，左半仍是较小的一半、右半是较大的一半，且左堆大小 ≥ 右堆大小、最多多 1。

## FindMedian()

- 若 **len(left) > len(right)**：总数为奇数，中位数 = **left 堆顶**。
- 否则：总数为偶数，中位数 = **(left 堆顶 + right 堆顶) / 2**。

## 复杂度

- **addNum**：O(log n)，两次堆的 Push/Pop。
- **findMedian**：O(1)，只读两个堆顶。
- 空间：O(n)。

## 实现要点

- **大顶堆**：可复用小顶堆，只重写 `Less(i, j)` 为 `h[i] > h[j]`（或嵌入小顶堆类型后只重写 Less），其余 Len/Swap/Push/Pop 复用。
- 使用标准库 `container/heap`，对 left/right 分别 `heap.Init` 后，用 `heap.Push` / `heap.Pop` 维护。
