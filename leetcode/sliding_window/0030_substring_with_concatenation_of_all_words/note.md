# 30. 串联所有单词的子串

## 题意

给定字符串 `s` 和等长单词列表 `words`，求 `s` 中所有「由 `words` 里全部单词各出现一次、顺序任意」的串联子串的起始下标。单词长度相同。

## 思路：按起始余数分组 + 滑动窗口（以单词为单位）

- 所有单词长度均为 `n`，所以合法子串一定从 `0, n, 2n, ...` 或 `1, 1+n, ...` 或 … 对齐。按**起始下标模 n** 分成 `n` 组，每组内起始位置形如 `i, i+n, i+2n, ...`，窗口按「单词」移动。
- 对每组做**滑动窗口**：
  - 用 `need` 统计每个单词需要出现的次数；
  - 窗口内用 `window` 统计当前每个单词出现次数，`matched` 表示当前窗口内「有效单词」个数（即未超 need 的单词总数，可理解为已凑满的单词种数或总个数，取决于实现）；
  - 右边界每次向右扩一个**单词** `s[r:r+n]`：
    - 若该词不在 `words` 里，则左边界直接拉到当前右边界之后，清空 `window`、`matched`；
    - 否则加入 `window`，若某词次数超过 `need`，则左边界每次左移一个单词并更新 `window`，直到该词次数合法；
  - 当窗口内单词组成恰好等于 `need`（即 `matched == len(words)` 且各词不超过 need）时，记录当前左边界 `l`，然后左边界右移一个单词，继续看后面是否还有以该 `l` 开头的合法串联（通常实现里是记录后立刻左移一位，再继续扩右边界）。
- 对 `i = 0..n-1` 各做一遍，所有记录的 `l` 即为答案。

## 要点

- 只枚举起始余数 `0..n-1`，窗口按**整词**步进，避免按字符枚举。
- 遇到不在 `words` 里的「词」时整段废弃，从下一词重新开始。
- 窗口内多出的词通过左边界右移（每次一个词）收缩，保证不超过 `need`。

## 复杂度

- 时间：O(n · (|s|/n)) = O(|s|)，n 为单词长度。
- 空间：O(words 长度 + 字符集)。
