# 76. 最小覆盖子串

## 题意

在字符串 `s` 中找一个最短的连续子串，使得该子串包含字符串 `t` 中的**所有字符**（每个字符出现次数不少于 `t` 中的次数）。若不存在则返回空串。

## 思路：滑动窗口 + 字符计数

- 用 **need[c]** 表示 `t` 中字符 `c` 需要的次数；**needCount** 表示 `t` 中有多少种不同字符（need[c] > 0 的个数）。
- 用 **window[c]** 表示当前窗口 `[l, r)` 内字符 `c` 的出现次数；**matched** 表示当前窗口内「已满足 need」的字符种类数（即满足 window[c] >= need[c] 的 c 的个数）。
- **右扩**：每次把 `s[r]` 加入窗口，`window[s[r]]++`；若某字符从「不足」变为「刚好够」（window[c] == need[c]），则 `matched++`。
- **左缩**：当 `matched == needCount` 时，当前窗口已覆盖 `t`。记录此时窗口长度与起点；然后左边界右移，`window[s[l]]--`，若某字符从「刚好够」变为「不足」，则 `matched--`，直到 `matched < needCount`。
- 在整段扫描过程中，取长度最小的合法窗口即为答案；若从未得到合法窗口则返回空串。

## 要点

- 用数组 `[128]int` 做 need/window 即可（题目为英文字母）。
- 「满足」的定义：对每个在 `t` 中出现的字符 c，都有 window[c] >= need[c]；用 matched 与 needCount 相等表示全部满足，避免每次遍历 need 检查。

## 复杂度

- 时间：O(|s| + |t|)。
- 空间：O(字符集大小)。
